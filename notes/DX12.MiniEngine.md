---
id: ve2f6hji0snc6m13c5sn083
title: MiniEngine
desc: ''
updated: 1668346438336
created: 1668254458711
---

## Initialize Graphics

在初始化的时候就设置好一些通用的Desc，包括SamplerDesc，DescriptorHandle，RasterizerDesc，BlendDesc，DepthStencilDesc。

![InitializeCommonState](/assets/images/InitializeCommonState.png)

---

## Resource

所有Resource都是通过`ID3D12Device::CreateCommittedResource`创建的。调用这个方法会同时创建一个*ID3D12Resource*和一个堆，这种堆称为*隐式堆（implicit heap）*，因为这种堆无法被App访问。在释放最后一个Resource的引用时，必须保证GPU不再读写这个资源。本质上都是Buffer，在Desc中需要指定这个Resource的类型：
![](/assets/images/CreateTextureResource.png)

![](/assets/images/ResourceDimension.png)

不同类型的Resource有不同的feature：

* Texture通常支持mipmap，filter，有一维，二维，三维的。
* 而Buffer就简单了，是一维的，且不支持mipmap，filter。用作顶点数据，ConstantBuffer。

创建的这些资源都是GPU资源，所以要指定Resource存放的堆的类型，不同类型的堆，CPU、GPU的访问权限不同。通常有[三种类型的堆](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ne-d3d12-d3d12_heap_type#constants)：

- `D3D12_HEAP_TYPE_DEFAULT` 
  - 大部分资源都位于默认堆，仅能被GPU访问。
  - 用于Texture，VertexData 等通常不会改变的数据。
- `D3D12_HEAP_TYPE_UPLOAD`
  - 上传堆，通常用于CPU写一次，GPU读一次。
  - 上传`ConstantBuffer`中的动态数据，会被每一个像素和顶点反复读取。
  - 上传资源到GPU，然后复制到Defaultheap.
  - Texture不能放这儿
* `D3D12_HEAP_TYPE_READBACK`
  * 用于CPU从GPU读回数据
  * 资源的初始状态必须是`D3D12_RESOURCE_STATE_COPY_DEST`

因为DefaultHeap中的资源只能被GPU访问，所以CPU还不能直接把数据传给它。而且Texture不能直接放到`_UPLOAD`堆中，这就需要先把Texture数据先以Buffer类型上传到_UPLOAD堆，然后再从_UPLOAD堆复制到_DEFAULT堆。
因此，不论是Texture资源还是顶点数据，都要先写到一个_UPLOAD堆的Resource中：

![](/assets/images/MapResource.png)

用`ID3D12Resource::Map`会开辟一块这个Resource的CPU虚拟地址范围，Umap会deallocate这块范围，且是线程安全的，可以多层嵌套调用。在用`Map`获得了CPU虚拟地址后，就可以用正常的*memcpy*向其中写入数据了。之后我们就可以进一步使用这个Resource了。

而纹理数据的创建则更复杂一些：
1. 以`D3D12_RESOURCE_STATE_COPY_DEST`为初始状态创建一个在_DEFAULT堆的Texture Resource.
   - 这个将作为最终创建好的GPU纹理资源
2. 创建一个_UPLOAD堆的BufferResource。
   - 大小和要复制的TextureResource一样，可以用`GetRequiredIntermediateSize()`直接获得。
3. 随后可以直接调用`UpdateSubresources`把数据先从CPU传给中间Resource，再在GPU上复制到真正的纹理Resource。
4. 最后还要把TextureResource的状态转换为`D3D12_RESOURCE_STATE_COPY_DEST`。
5. 还需要保证GPU执行完这些命令之前对中间Resource有引用，这里需要同步一次。
6. 完了就得到了一个可用的纹理Resource。

这里上传资源的实现需要支持各种类型的Resouce，还有Mipmap之类的，所以比较麻烦，可以直接用`UpdateSubresources`，当然也可以自己实现。


## Asset bind   

## Texture manage

