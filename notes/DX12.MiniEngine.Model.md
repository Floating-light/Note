---
id: 0mgnzscvpzf7jjo1ta03whf
title: Model
desc: ''
updated: 1715474414502
created: 1670806808115
---

# ModelH3D

## Header m_Header
保存这个Model的一些基本信息：
* mesh数量
* material数量
* 顶点数据Size
* 索引数据Size
* BoundingBox
且这个结构体与数据Header的布局一致，可以直接读到这个结构的内存块中。

然后按照这些Header的数据读取后续的大块数据，通常顶点，索引数据都是放在一起的，算出它们的SIze后可以可以直接读到一个大的Buffer中（UploadBuffer），然后通过地址偏移引用它们。

然后加载所有纹理，根据材质的设置，这里所有材质都是6张纹理，所有这些纹理SRV保存在一块连续heap中，没有的用默认texture代替。这里表明，所有材质都是预先设置好的。

## indices buffer optimize
对indices进行重排，vertex cache optimization. 最大化"post-transform vertex cache reuse"。这种优化通常与硬件的CacheSize相关，CacheSize不匹配会导致负优化。

`OptimizeFaces()`

https://github.com/microsoft/DirectXMesh/wiki/OptimizeFaces

## mesh data 
用PSOFlags表明这个Mesh有什么顶点数据。vertex buffer和indeces buffer等按实际情况组织。`OptimizeMesh()`
所有Mesh的数据都存在一个Buffer里面`Renderer::CompileMesh()`，组成一个Model。
```c++
// All of the information that needs to be written to a .mini data file
struct ModelData
{
    BoundingSphere m_BoundingSphere; 
    AxisAlignedBox m_BoundingBox;
    std::vector<byte> m_GeometryData;
    std::vector<byte> m_AnimationKeyFrameData;
    std::vector<AnimationCurve> m_AnimationCurves;
    std::vector<AnimationSet> m_Animations;
    std::vector<uint16_t> m_JointIndices;
    std::vector<Matrix4> m_JointIBMs;
    std::vector<MaterialTextureData> m_MaterialTextures;
    std::vector<MaterialConstantData> m_MaterialConstants;
    std::vector<Mesh*> m_Meshes;
    std::vector<GraphNode> m_SceneGraph;
    std::vector<std::string> m_TextureNames;
    std::vector<uint8_t> m_TextureOptions;
};
struct Mesh
{
    float    bounds[4];     // A bounding sphere
    uint32_t vbOffset;      // BufferLocation - Buffer.GpuVirtualAddress
    uint32_t vbSize;        // SizeInBytes
    uint32_t vbDepthOffset; // BufferLocation - Buffer.GpuVirtualAddress
    uint32_t vbDepthSize;   // SizeInBytes
    uint32_t ibOffset;      // BufferLocation - Buffer.GpuVirtualAddress
    uint32_t ibSize;        // SizeInBytes
    uint8_t  vbStride;      // StrideInBytes
    uint8_t  ibFormat;      // DXGI_FORMAT
    uint16_t meshCBV;       // Index of mesh constant buffer
    uint16_t materialCBV;   // Index of material constant buffer
    uint16_t srvTable;      // Offset into SRV descriptor heap for textures
    uint16_t samplerTable;  // Offset into sampler descriptor heap for samplers
    uint16_t psoFlags;      // Flags needed to request a PSO
    uint16_t pso;           // Index of pipeline state object
    uint16_t numJoints;     // Number of skeleton joints when skinning
    uint16_t startJoint;    // Flat offset to first joint index
    uint16_t numDraws;      // Number of draw groups

    struct Draw
    {
        uint32_t primCount;   // Number of indices = 3 * number of triangles
        uint32_t startIndex;  // Offset to first index in index buffer 
        uint32_t baseVertex;  // Offset to first vertex in vertex buffer
    };
    Draw draw[1];           // Actually 1 or more draws
};
```
### primitive 
```c++
struct Primitive
{
    BoundingSphere m_BoundsLS;  // local space bounds
    BoundingSphere m_BoundsOS;  // object space bounds
    AxisAlignedBox m_BBoxLS;       // local space AABB
    AxisAlignedBox m_BBoxOS;       // object space AABB
    Utility::ByteArray VB;
    Utility::ByteArray IB;
    Utility::ByteArray DepthVB;
    uint32_t primCount;
    union
    {
        uint32_t hash; // 与下面结构体共享一块内存
        struct {
            uint32_t psoFlags : 16; // 前16个bit表示pso相关配置的枚举项(输入layout，alphatest等配置)
            uint32_t index32 : 1; // indices是不是32bit的(or 16bit)
            uint32_t materialIdx : 15; // 材质索引
        };
        // Primitive.psoFlags, Primitive.index32, Primitive.materialidx可以直接访问或设置这三个部分
        // 也可以用Primitive.hash，用这三种配置组成唯一hash值,以判断两个PSO配置是否一样.
    };
    uint16_t vertexStride;
};
```